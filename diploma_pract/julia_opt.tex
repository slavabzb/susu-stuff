\subsection{Разработка решателя}
\label{juliaopt}

Пакеты для математической оптимизации в Julia представляют собой единое пространство JuliaOpt.

Пакеты JuliaOpt построены на основе MathProgBase.jl -- прослойке абстракции, предоставляющей высокоуровневые функции для линейного и целочисленного программирования, а также набор низкоуровневых функций для создания новых алгоритмов (см. рисунок~\ref{i:juliaopt}, показана зеленым). Над уровнем абстракции расположены языки моделирования (красный), а ниже -- интерфейсы внешних библиотек для решения ЗЛП (фиолетовый).

\begin{figure}
\centering
\includegraphics[scale=0.5]{i/juliaopt.png} 
\caption{Обзор существующих пакетов для математической оптимизации в Julia\label{i:juliaopt}}
\end{figure}


JuliaOpt предоставляет 2 языка моделирования для решения ЗЛП:
\begin{itemize}
\item\textbf{JuMP} -- алгебраический язык моделирования для задач оптимизации с линейными, квадратичными и нелинейными ограничениями. Генерирует модели также быстро, как аналогичные коммерческие утилиты, а также поддерживает дополнительные возможности, такие, как функции обратного вызова для решателей.
\item\textbf{Convex.jl} -- алгебраический язык моделирования для высокодисциплинированного выпуклого программирования.
\end{itemize}

Пакет MathProgBase.jl определяет модуль~\textit{SolverInterface}, который представляет собой абстракцию над низкоуровневыми интерфейсами, общими для большинства библиотек. Модуль~\textit{SolverInterface} определяет такие высокоуровневые функции, как~\texttt{linprog}, \texttt{mixintprog} и~\texttt{quadprog}, которые не зависят от используемой для решения ЗЛП библиотеки. Языки моделирования~\textit{JuMP} и~\textit{Convex.jl} используют интерфейсы этого модуля для обмена информацией с различными решателями.

Существует 3 категории решателей (некоторые решатели могут принадлежать к более чем одной категории):
\begin{itemize}
\item\textbf{LinearQuadratic} -- решают линейные и квадратичные задачи программирования и принимают на вход данные в виде матриц, определяющих линейные и квадратичные компоненты ограничений и целевую функцию. Примерами решателей этой категории являются \texttt{Cbc}, \texttt{Clp}, \texttt{CPLEX}, \texttt{GLPK}, \texttt{Gurobi} и \texttt{Mosek}.
\item\textbf{Conic} -- решают конические задачи программирования. Входной формат таких решателей предсталяет собой матрицы и векторы, определяющие афинные функции и список конусов. Примерами являются \texttt{ECOS}, \texttt{Mosek} и \texttt{SCS}.
\item\textbf{Nonlinear} -- традиционные нелинейные решатели, которым необходим доступ к алгебраическому представлению задачи. Примеры этой категории: \texttt{AmpINLWriter}, \texttt{CoinOptServices}, \texttt{Lpopt}, \texttt{KNITRO}, \texttt{MOSEK} и \texttt{NLopt}.
\end{itemize}

Разделение решателей на небольшое число категорий позволяет легко реализовать автоматический перевод задачи между разными представлениями. Это необходимо для перевода ЗЛП из пользовательского представления в структуры данных, которые принимают на вход решатели.

Модуль~\textit{SolverInterface} разделяет понятия "решатель" и "модель". Решатель -- это небольшой объект, используемый для настройки параметров, он не хранит никаких данных задачи. Решатель используется для создания объекта модели -- представление задачи решателя в оперативной памяти.

В файле \texttt{DrsMathProgSolverInterface.jl} определяется модуль решателя, производится настройка уровня логирования и подключаются необходимые библиотеки.

\lstinputlisting[firstline=1,lastline=9]{SolverInterface.jl}

Далее следует секция экспорта, определяющая, какие методы и сущности будут видны пользователям модуля.

\lstinputlisting[firstline=11,firstnumber=11,lastline=19]{SolverInterface.jl}

Потом следуют определения решателя и модели -- абстракции, используемые далее в коде для решения ЗЛП.

\lstinputlisting[firstline=21,firstnumber=21,lastline=33]{SolverInterface.jl}

Решение задачи начинается с функции инициализации, в которой задаются исходные данные и производится первоначальная настройка.

\lstinputlisting[firstline=55,firstnumber=55,lastline=67]{SolverInterface.jl}

Прежде, чем переходить к решению ЗЛП, необходимо привести ее к стандартной форме (тело функции довольно объемно, полный исходный код см. в приложении~\ref{append:src}) и найти первоначальный базис.

\lstinputlisting[firstline=69,firstnumber=69,lastline=82]{SolverInterface.jl}

Модуль также определяет различные функции опроса статуса и получения результата решения задачи.
