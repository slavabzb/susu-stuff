\subsection{Параллельный вызов функций решателя}
\label{julia_parallel}

Передача сообщений между процессами в Julia несколько отличается от других сред, таких как MPI. Общение зачастую "одностороннее", т.е. программист явно управляет только одним главным процессом.

Параллельное программирование в Julia строится на 2 примитивах: \textit{удаленных ссылках} и \textit{удаленных вызовах}. Удаленная ссылка -- это объект, который может быть использован любым процессом для идентификации объекта, созданного в контексте какого-либо процесса. Удаленный вызов -- это запрос процесса к другому процессу выполнить определенную функцию на некотором наборе аргументов.

Удаленный вызов возвращает объект \texttt{Future} в качестве результата. Объект возвращается немедленно; процесс, сделавший вызов, продолжает выполение следующих операций, в то время как удаленный вызов выполняется в другом процессе. Результат выполнения операции будет доступен в объекте \texttt{Future}.

В алгоритме симплекс-метода параллельное выполнение приходится на шаги \texttt{BTRAN} и \texttt{PRICE}.

\lstinputlisting[firstline=183,firstnumber=183,lastline=189]{SolverInterface.jl}

Выполнение блока начинается с удаленного вызова \texttt{BTRAN}  для выполнения в другом процессе. Объект \texttt{Future}, хранящий в себе числовой результат, будет доступен сразу после выполнения операции. Результат передается функции \texttt{PRICE}, также запускаемой удаленно.

Для параллельной обработки данных в Julia предусмотрены специальные структуры данных. \texttt{DistributedArrays} предназначены для оперирования массивами, размеры который слишком велики для одной ЭВМ. Каждый процесс при этом обрабатывает только свою часть массива, которая доступна локально. Но реализация алгоритма использует \texttt{SharedArray}.

\lstinputlisting[firstline=164,firstnumber=164,lastline=165]{SolverInterface.jl}

\texttt{SharedArray} позволяет нескольким процессам получить доступ к общим данным. Поскольку метод основан на вычислениях с обратной матрицей, доступ к ней должен осуществляться практически с любого шага алгоритма не зависимо от того, на каком процессе он выполняется.
