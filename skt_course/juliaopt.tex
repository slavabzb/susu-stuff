\subsubsection{Задачи оптимизации в Julia}
\label{julia_opt}

Пакеты для математической оптимизации в Julia представляют собой единое пространство JuliaOpt.

Пакеты JuliaOpt построены на основе MathProgBase.jl -- прослойке абстракции, предоставляющей высокоуровневые функции для линейного и целочисленного программирования, а также набор низкоуровневых функций для создания новых алгоритмов (см. рисунок~\ref{i:juliaopt}, показана зеленым). Над уровнем абстракции расположены языки моделирования (красный), а ниже -- интерфейсы внешних библиотек для решения ЗЛП (фиолетовый).

\begin{figure}
\centering
\includegraphics[scale=0.5]{i/juliaopt.png} 
\caption{Обзор существующих пакетов для математической оптимизации в Julia\label{i:juliaopt}}
\end{figure}


JuliaOpt предоставляет 2 языка моделирования для решения ЗЛП:
\begin{itemize}
\item\textbf{JuMP} -- алгебраический язык моделирования для задач оптимизации с линейными, квадратичными и нелинейными ограничениями. Генерирует модели также быстро, как аналогичные коммерческие утилиты, а также поддерживает дополнительные возможности, такие, как функции обратного вызова для решателей.
\item\textbf{Convex.jl} -- алгебраический язык моделирования для высокодисциплинированного выпуклого программирования.
\end{itemize}

Пакет MathProgBase.jl определяет модуль~\textit{SolverInterface}, который представляет собой абстракцию над низкоуровневыми интерфейсами, общими для большинства библиотек. Модуль~\textit{SolverInterface} определяет такие высокоуровневые функции, как~\texttt{linprog}, \texttt{mixintprog} и~\texttt{quadprog}, которые не зависят от используемой для решения ЗЛП библиотеки. Языки моделирования~\textit{JuMP} и~\textit{Convex.jl} используют интерфейсы этого модуля для обмена информацией с различными решателями.

Существует 3 категории решателей (некоторые решатели могут принадлежать к более чем одной категории):
\begin{itemize}
\item\textbf{LinearQuadratic} -- решают линейные и квадратичные задачи программирования и принимают на вход данные в виде матриц, определяющих линейные и квадратичные компоненты ограничений и целевую функцию. Примерами решателей этой категории являются \texttt{Cbc}, \texttt{Clp}, \texttt{CPLEX}, \texttt{GLPK}, \texttt{Gurobi} и \texttt{Mosek}.
\item\textbf{Conic} -- решают конические задачи программирования. Входной формат таких решателей предсталяет собой матрицы и векторы, определяющие афинные функции и список конусов. Примерами являются \texttt{ECOS}, \texttt{Mosek} и \texttt{SCS}.
\item\textbf{Nonlinear} -- традиционные нелинейные решатели, которым необходим доступ к алгебраическому представлению задачи. Примеры этой категории: \texttt{AmpINLWriter}, \texttt{CoinOptServices}, \texttt{Lpopt}, \texttt{KNITRO}, \texttt{MOSEK} и \texttt{NLopt}.
\end{itemize}

Разделение решателей на небольшое число категорий позволяет легко реализовать автоматический перевод задачи между разными представлениями. Это необходимо для перевода ЗЛП из пользовательского представления в структуры данных, которые принимают на вход решатели.

Модуль~\textit{SolverInterface} разделяет понятия "решатель" и "модель". Решатель -- это небольшой объект, используемый для настройки параметров, он не хранит никаких данных задачи. Решатель используется для создания объекта модели -- представление задачи решателя в оперативной памяти.
