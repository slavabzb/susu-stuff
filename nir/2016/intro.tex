\freesection{Содержание выполненных работ}

В дипломной работе \textit{<<Параллельная реализация метода эллипсоидов для задач оптимизации большой размерности>>} был произведен анализ вычислительной сложности выполняемых операций алгоритма метода эллипсоидов. На основе результатов анализа была разработана параллельная реализация метода эллипсоидов, адаптированная для решения задач оптимизации большой размерности на многопроцессорных и/или многоядерных вычислительных системах с общей разделяемой памятью.

Структура и содержание выполненных работ направлены на \textit{развитие идей} дипломной работы, сформулированных как направления дальнейших исследований. В частности, предлагалось повысить эффективность работы с типами данных произвольной точности, применить последние алгоритмические разработки в области параллельного умножения матриц, а также использовать модификации метода эллипсоидов для решения одномерных задач оптимизации.

Ядро существующей реализации было полностью переписано на C\cite{kern_ritch_2007}. Исправлены найденные недочеты и уязвимости. Поскольку С не поддерживает сложные структуры данных\cite{shildt2010}, а предоставляет для этого низкоуровневый механизм структур (\texttt{struct}, POD), был введен тип данных, представляющий матрицы в программном коде (см. листинг 1).

{\footnotesize
\begin{verbatim}
    /**
     * Matrix structure.
     */
    struct mtx
    {
        mpfr_t* storage;     ///!< internal storage
        size_t nrows;        ///!< number of rows
        size_t ncols;        ///!< number of columns
    };
\end{verbatim}
}
%
\noindent
{\small\textbf{Листинг 1.} Представление матриц в программном коде: \textit{storage} -- это указатель на выделенный участок памяти, \textit{nrows} и \textit{ncols} используются для адресной арифметики.\bigskip}

Элементы матрицы имеют тип \texttt{mpfr\_t}. Это специализированный тип данных из библиотеки GNU MPFR Library\cite{mpfr} -- портативной библиотеки, написанной на С, для арифметики произвольной точности над числами с плавающей запятой. Она основана на GNU MP Library\cite{gmp}. Библиотека предоставляет класс чисел с плавающей запятой с точной семантикой. Основными преимуществами библиотеки MPFR от аналогов являются:

\begin{itemize}
\item код MPFR портативен, т.е. результат любой операции не зависит от размера машинного слова \texttt{mp\_bits\_per\_limb} (64 для большинства современных процессоров);
\item точность в битах может быть задана явно для любых допустимых значений для каждой переменной (включая очень маленькую точность);
\item библиотека MPFR предоставляет четыре режима округления из стандарта IEEE 754-1985 как для базовых операций, так и для других математических функций.
\end{itemize}

Для работы с введенным типом матриц был разработан простой базовый интерфейс библиотеки. Сигнатуры некоторых методов представлены в листинге 2.

{\footnotesize
\begin{verbatim}
    // memory handling
    int mtx_init(struct mtx* const m,
            size_t rows, size_t columns, mpfr_prec_t prec);

    int mtx_clear(struct mtx const m);

    // matrix I/O
    int mtx_fprint(FILE* stream, struct mtx const m);
    int mtx_fscan(FILE* stream, struct mtx m, char const* delim);

    // assignment
    int mtx_fill(struct mtx m, mpfr_t val, mpfr_t diagval);
    int mtx_fill_d(struct mtx m, double val, double diagval);

    // copying
    int mtx_copy(struct mtx rop, struct mtx const op);

    // multiplication
    int mtx_mul(struct mtx rop,
            struct mtx const op1, struct mtx const op2);

    int mtx_mulval(struct mtx rop, struct mtx const op1, mpfr_t op2);

    // addition
    int mtx_add(struct mtx rop,
            struct mtx const op1, struct mtx const op2);

    // transposition
    int mtx_tr(struct mtx rop, struct mtx const op);
\end{verbatim}
}
%
\noindent
{\small\textbf{Листинг 2.} Интерфейс библиотеки для работы с матрицами.\bigskip}

Все функции сгруппированы в соответствии с типом выполняемых операций:

\begin{itemize}
\item\textbf{управление памятью} -- создание/удаление матриц с выделением/освобождением динамической памяти (параметр \texttt{prec} задает число бит, используемых для представления мантиссы числа с плавающей точкой, параметр может принимать любые значения от \texttt{MPFR\_PREC\_MIN} до \texttt{MPFR\_PREC\_MAX});
\item\textbf{средства ввода/вывода} -- чтение/запись матриц из/в различные источники;
\item\textbf{операции присваивания} -- функции заполнения матриц значением (параметр \texttt{diagval} используется для заполнения элементов на диагонали, если матрица квадратная);
\item\textbf{базовые операции} -- матричное умножение, умножение на число, сложение, транспонирование и копирование.
\end{itemize}

Каждая функция в качестве возвращаемого значения использует ненулевое значение при возникновении ошибки.

Большинство функций библиотеки MPFR принимают дополнительный параметр, называемый \textit{порядок округления}. Библиотека поддерживает следующие пять режимов:

\begin{itemize}
\item\textbf{MPFR\_RNDN} -- округление к ближайшему (roundTiesToEven из IEEE 754-2008),
\item\textbf{MPFR\_RNDZ} -- округление к нулю (roundTowardZero из IEEE 754-2008),
\item\textbf{MPFR\_RNDU} -- округление к плюс бесконечности (roundTowardPositive из IEEE 754-2008),
\item\textbf{MPFR\_RNDD} -- округление к минус бесконечности (roundTowardNegative из IEEE 754-2008),
\item\textbf{MPFR\_RNDA} -- округление от нуля.
\end{itemize}

Благодаря своей природе, большинство матричных операций могут быть выполнены параллельно без гонки за данными, захвата ресурсов и с минимальным набором разделяемых данных. По этой причине большинство функций из листинга 2 были распараллелены для ускорения.

Сегодня существует много способов организации параллелизма. Одним из наиболее популярных, современных и гибких является интерфейс OpenMP\cite{openmp}, поддерживающий мультиплатформенное мультипроцессорное программирование на C, C++ и Fortran\cite{gagne} для распределенных систем с разделяемой памятью на большинстве современных платформ, включая Solaris, AIX, HP-UX, Linux, OS X и Windows. Интерфейс состоит из набора директив компилятора, библиотечных функций и переменных окружения, определяющих поведение времени исполнения.

OpenMP использует портативную, расширяемую модель и предоставляет программистам простой и гибкий интерфейс для разработки параллельных приложений для различных платформ, от стандартного настольного десктопа до суперкомпьютера.

Приложения, созданные с помощью гибридной модели параллельного программирования, могут быть запущены на кластере, использующем как OpenMP, так и MPI, при этом OpenMP обеспечивает параллелизм внутри многоядерного узла, в то время как MPI обеспечивает параллелизм между разными узлами. Также существует возможность запустить OpenMP на распределенных системах с разделяемой памятью\cite{costa2006} для трансляции OpenMP в MPI\cite{wang2010, basumallik2007} либо для расширения OpenMP для систем с неразделяемой памятью.

Все сложности организации многопоточного кода библиотека работы с матрицами скрывает <<за кулисами>>. Код, который необходимо выполнить параллельно, помечается как \textit{параллельная область OpenMP}. Для назначения отдельной работы одному или всем потокам используются специальные конструкции. Директивы \texttt{omp for} или \texttt{omp do} необходимы для разделения итераций цикла между потоками. Пример объявления параллельного цикла представлен в листинге 3.

{\footnotesize
\begin{verbatim}
    size_t i, j, k;

#pragma omp parallel for
    shared(rop) private(i,j,k) schedule(static)
    
    for (i = 0; i < op1.nrows; ++i)
    {
        for (j = 0; j < op2.ncols; ++j)
        {
            // do something ...
        }
    }
\end{verbatim}
}
%
\noindent
{\small\textbf{Листинг 3.} Параллельно выполняемый цикл.\bigskip}

Поскольку OpenMP является моделью программирования для разделяемой памяти, большинство переменных по умолчанию видимы для всех потоков. Но иногда для избежания гонки потоков или для передачи значений между последовательными частями и параллельной областью необходимы закрытые переменные. Управление расположением данных реализуется через указания атрибута разделения данных. Вот некоторые типы:

\begin{itemize}
\item\textbf{shared} -- данные внутри параллельной области разделяемы, что означает их доступность для всех потоков одновременно. По умолчанию, все переменные разделяемы за исключением счетчика итераций цикла.
\item\textbf{private} -- данные внутри параллельной области являются локальными для каждого потока. Это означает, что каждый поток будет иметь собственную копию данных и использовать их как временные переменные. Закрытые данные не инициализируются, и их значение не может быть использовано вне параллельного региона. По умолчанию счетчики итераций цикла являются закрытыми в OpenMP.
\end{itemize}

Одним из \textit{режимов планирования} является \texttt{schedule(type, chunk)}. Он используется по умолчанию для циклов \texttt{do} и \texttt{for}. Итерации назначаются потокам в соответствии с режимом планирования. При использовании режима \texttt{static}, итерации назначаются потокам перед началом выполнения цикла. По умолчанию итерации распределяются между потоками равномерно. Хотя, указание целочисленного значения в качестве параметра \texttt{chunk} приведет к назначению указанного количества последовательных итераций каждому потоку.

Именно таким образом библиотека работы с матрицами разрешает вопрос обработки матриц большого размера за приемлемое время. Разумеется, не все операции могут быть выполнены параллельно (например, ввод/вывод матриц).

\freesection{Направления будущих исследований}

Необходимо применить метод эллипсоидов, построенный на основе параллельной библиотеки для работы с матрицами, для задач линейного программирования больших размерностей, собрать необходимые метрики (время работы, количество затрачиваемых итераций) и сравнить эффективность алгоритма с традиционными алгоритмами решения ЗЛП (симплекс-метод).
